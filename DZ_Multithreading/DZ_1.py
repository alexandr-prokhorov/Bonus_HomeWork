# Описание задачи:
# Напишите многопоточную программу, которая имитирует работу системы
# уведомлений. Система должна отправлять уведомления разным пользователям с
# разными задержками.
# Указания:
# 1. Создайте функцию send_notification(user, delay), которая принимает имя
# пользователя (user) и задержку (delay) в секундах.
# o Функция должна:
# ▪ Выводить сообщение о начале отправки уведомления.
# ▪ Использовать time.sleep(delay) для имитации времени отправки.
# ▪ Выводить сообщение о завершении отправки уведомления.
# 2. В основной функции программы:
# o Создайте список пользователей и задержек отправки, например:
# users = [("Alice", 2), ("Bob", 3), ("Charlie", 1), ("Diana", 4)]
# o Для каждого пользователя создайте поток с помощью threading.Thread.
# o Запустите все потоки одновременно.
# o Используйте join() для ожидания завершения всех потоков.
# Ожидаемый результат:
# Программа должна конкурентно отправлять уведомления, и сообщения о начале и
# завершении отправки будут появляться в случайном порядке, соответствующем
# задержкам.
# Пример вывода программы
# Начинаю отправку уведомления для Alice...
# Начинаю отправку уведомления для Bob...
# Начинаю отправку уведомления для Charlie...
# Начинаю отправку уведомления для Diana...
# Уведомление для Charlie отправлено!
# Уведомление для Alice отправлено!
# Уведомление для Bob отправлено!
# Уведомление для Diana отправлено!


import threading
import time


def send_notification(user, delay):
    print(f'Начинаю отправку уведомления для {user}...')
    time.sleep(delay)
    print(f'Уведомление для {user} отправлено!')


def main():
    users = [("Alice", 2),
            ("Bob", 3),
            ("Charlie", 1),
            ("Diana", 4)
            ]
    threads = []
    for user, delay in users:
        thread = threading.Thread(target=send_notification, args=(user, delay))
        threads.append(thread)
        thread.start()
    for thread in threads:
        thread.join()

if __name__ == '__main__':
    main()

